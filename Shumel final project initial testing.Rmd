---
title: "Shumel- final project initial testing"
output: html_document
---
---
title: "Investigating the Relationship between Mental Health and Income Inequality"
author: "Team 6: Mark Febrizio, Shumel Siraj, Alex Thiersch, Xuan Zou"
#date: "3/28/2022"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r init, include=F}

# Import libraries
library(ezids)
library(dplyr)
library(data.table)
library(readr)
library(lattice)
library(corrplot)
library(psych)
library(kableExtra)
library(ggpubr)

```

```{r setup, include=FALSE}

# knitr::opts_chunk$set(warning = F, results = "markup", message = F)
knitr::opts_chunk$set(warning = F, results = "hide", message = F, echo = TRUE)
options(scientific=T, digits = 3) 
# options(scipen=9, digits = 3) 
# ‘scipen’: integer. A penalty to be applied when deciding to print numeric values in fixed or exponential notation.  Positive values bias towards fixed and negative towards scientific notation: fixed notation will be preferred unless it is more than ‘scipen’ digits wider.
# use scipen=999 to prevent scientific notation at all times

```
## Summary

The variables in the dataset are:

* `region`: name of the US Census Bureau region (name)
* `division`: name of the US Census Bureau division (contained with a census region)
* `state`: state abbreviation
* `statecode`: FIPS state code
* `countycode`: FIPS county code
* `fipscode`: 5-digit FIPS Code (county-level); combines `statecode` and `countycode`
* `county`: county name
* `year`: report release year from [County Health Rankings](https://www.countyhealthrankings.org/); range of 2016-2021
* `county_ranked`: Indicates whether or not the county was ranked; 0=unranked, 1=ranked, or NA for aggregated national or state-level data
* `mental_health_days`: Average number of mentally unhealthy days reported in past 30 days (age-adjusted)
* `mental_distress_rate`: Percentage of adults reporting 14 or more days of poor mental health per month
* `inequality`: Ratio of household income at the 80th percentile to income at the 20th percentile (Income inequality)
* `median_inc`: The income where half of households in a county earn more and half of households earn less
* `hs_grad`: Percentage of adults ages 25 and over with a high school diploma or equivalent
* `college`: Percentage of adults ages 25-44 with some post-secondary education
* `unempl`: Percentage of population ages 16 and older unemployed but seeking work
* `child_poverty`: Percentage of people under age 18 in poverty
* `single_parent`: Percentage of children that live in a household headed by single parent
* `severe_housing`: Percentage of households with severe housing problems
* `food_index`: Index of factors that contribute to a healthy food environment, from 0 (worst) to 10 (best)
* `mh_providers`: rate of providers to 100,000 population
* `pop_provider_ratio`: ratio of population to mental health providers (i.e., population served per provider)
* `pop`: census population estimate
* `pct_below18`: percent of population younger than 18
* `pct_black`: percent of population that are African-American or non-Hispanic Black
* `pct_native_am`: percent of population that are Native American or Alaska Natives
* `pct_asian`: percent of population that are Asian
* `pct_pacific`: percent of population that are Native Hawaiian or Other Pacific Islander
* `pct_hispanic`: percent of population that are Hispanic
* `pct_white`: percent of population that are non-Hispanic white or Caucasian
* `pct_female`: percent of population that are female
* `pct_rural`: percent of population that live in rural areas

For more information, see [the measures online](https://www.countyhealthrankings.org/explore-health-rankings/measures-data-sources/2021-measures).

```{r base_lib}
loadPkg("ggplot2")
```

## Initialize

```{r}
dframe <- data.frame(read.csv("analytic_data_2016_2021_with_regions.csv")) 
head(dframe)
summary(dframe)
```  

```{r summary, results='hide'}

# look at county_ranked var; not all counties are ranked; also some aggregated data per state and country exist in the observations
# =1 means they are ranked, =0 means unranked, and =NA is for state/national data
#print(summary(dframe$county_ranked))

# subset of dataframe including only ranked counties
ranked <- dframe %>% subset(county_ranked==1)

# subset of dataframe including only ranked counties
unranked <- dframe %>% subset(county_ranked==0)

# subset of dataframe including only aggregated data
aggregated <- dframe %>% subset(is.na(county_ranked))

# duplicate column and rename level labels for easier reading
ranked$region_abb <- ranked$region
levels(ranked$region_abb) <- c("", 
                              "MW",  # re-level factor labels
                              "NE",
                              "S", 
                              "W")

# subset ranked data by region
ranked_MW <- ranked %>% subset(region=="Midwest")
ranked_NE <- ranked %>% subset(region=="Northeast")
ranked_SO <- ranked %>% subset(region=="South")
ranked_WE <- ranked %>% subset(region=="West")

# subset ranked data into annual datasets
ranked16 <- ranked %>% subset(year==2016)
ranked17 <- ranked %>% subset(year==2017)
ranked18 <- ranked %>% subset(year==2018)
ranked19 <- ranked %>% subset(year==2019)
ranked20 <- ranked %>% subset(year==2020)
ranked21 <- ranked %>% subset(year==2021)

# view size of annual datasets
df_annual_list <- list(ranked16, ranked17, ranked18, ranked19, ranked20, ranked21)
for (df in df_annual_list) {
  print(paste("Observations in", median(df$year), "data: ", nrow(df)))
  
}

# sort dataframe
ranked <- ranked[order(ranked$year, ranked$region, ranked$division, ranked$statecode, ranked$countycode), ]

# view head and tail of ranked data
xkabledplyhead(ranked, 2, title = "Table: First 2 Rows of Ranked Data")
xkabledplytail(ranked, 2, title = "Table: Last 2 Rows of Ranked Data")
```


# Correlation Matrices for numeric data
```{r corr, results='markup'}



ranked_numeric <- subset(ranked, select = c("mental_health_days", "mental_distress_rate", "inequality", "median_inc", "hs_grad", "college", "unempl", "child_poverty","single_parent", "severe_housing", "food_index","mh_providers","pop_provider_ratio"))

#pairs(ranked_numeric)

a <- as.matrix(ranked_numeric)

b <- cor(a, use = "na.or.complete")

#corr_numbers <- corrplot(b, is.corr=TRUE, method="number", title="Correlation Matrix for Numeric Vars.",mar=c(0,0,1,0))

corr_numbers <- corrplot(b, is.corr=TRUE, title="Correlation Matrix for Numeric Vars.",mar=c(0,0,1,0))

```
#Feature Selection

```{r}
loadPkg("ISLR")
str(ranked)
summary(ranked)
```
One thing we can do right away is to clean up the data a little. Remove variables that we know for sure are useless.
In our case, let us remove some cumulative player stats to make the dataframe more manageable.

```{r}
#rankedfsf = ranked[ -c(1:9) ] # cleaned datasetnndf <- nndf1[c(1:23)]
rankedfs = ranked [c(10:33)] 
head(rankedfs)
```
```{r}
#1.Perform Linear Regression with All Predictors
#Before selecting the best subset of predictors for our regression, let’s run a simple linear regression on our dataset with all predictors to set the base adjusted r² for comparison.

lm1 <- lm(rankedfs,formula=mental_health_days ~.)
summary(lm1)

```
#Details
Since this function returns separate best models of all sizes up to nvmax and since different model
selection criteria such as AIC, BIC, CIC, DIC, ... differ only in how models of different sizes are
compared, the results do not depend on the choice of cost-complexity tradeoff.
When x is a biglm object it is assumed to be the full model, so force.out is not relevant. If there
is an intercept it is forced in by default; specify a force.in as a logical vector with FALSE as the
first element to allow the intercept to be dropped.
The model search does not actually fit each model, so the returned object does not contain coefficients or standard errors. Coefficients and the variance-covariance matrix for one or model models
can be obtained with the coef and vcov methods.

```{r}
library(ISLR)
library(leaps)
rankedfs <- na.omit(rankedfs)
regfit.full = regsubsets(mental_health_days ~.,rankedfs, nvmax=23)
reg.summary <- summary(regfit.full)
names(reg.summary)
```
```{r}
plot(reg.summary$rsq,xlab="number of variables", ylab="RSquare", type="l")
plot(reg.summary$rss,xlab="number of variables", ylab="RSS", type="l")
plot(reg.summary$adjr2,xlab="number of variables", ylab="adjr2", type="l")
plot(reg.summary$cp,xlab="number of variables", ylab="cp", type="l")
plot(reg.summary$bic,xlab="number of variables", ylab="BIC", type="l")
```
